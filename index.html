<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - loaders - MMD loader</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      font-family: Monospace;
      background-color: #fff;
      color: #000;
      margin: 0px;
      overflow: hidden;
    }

    #info {
      color: #000;
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      display: block;
    }

    #info a,
    .button {
      color: #f00;
      font-weight: bold;
      text-decoration: underline;
      cursor: pointer
    }

  </style>
</head>

<body>
  <div id="info">
    modefied from <a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - MMDLoader test by Florencea Bear.<br />
    <a href="https://github.com/mrdoob/three.js/tree/master/examples/models/mmd#readme" target="_blank" rel="noopener">MMD Assets license</a><br /> Copyright
    <a href="http://www.geocities.jp/higuchuu4/index_e.htm" target="_blank" rel="noopener">Model Data</a>
    <a href="http://www.nicovideo.jp/watch/sm13147122" target="_blank" rel="noopener">Dance Data</a>
  </div>

  <script src="three.min.js"></script>

  <script src="mmdparser.min.js"></script>
  <script src="ammo.js"></script>

  <script src="TGALoader.js"></script>
  <script src="MMDLoader.js"></script>
  <script src="OutlineEffect.js"></script>
  <script src="CCDIKSolver.js"></script>
  <script src="MMDPhysics.js"></script>

  <script src="OrbitControls.js"></script>

  <script src="Detector.js"></script>
  <script src="stats.min.js"></script>
  <script src="dat.gui.min.js"></script>
  <script src="jquery-3.2.1.slim.min.js"></script>

  <script>
    //by Florencea Bear
    let gf = 20;
    let gg = 0;

    let globala = 10;
    let a = 0;
    let ny = -10;

    //end

    var container, stats;

    var mesh, camera, scene, renderer, effect;
    var helper, ikHelper, physicsHelper;

    var mouseX = 0,
      mouseY = 0;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var clock = new THREE.Clock();

    function init() {

      container = document.createElement('div');
      document.body.appendChild(container);

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
      camera.position.z = 30;

      // scene

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      var gridHelper = new THREE.PolarGridHelper(100, 10);
      gridHelper.position.y = -10;
      scene.add(gridHelper);

      var ambient = new THREE.AmbientLight(0x666666);
      scene.add(ambient);

      var directionalLight = new THREE.DirectionalLight(0x887766);
      directionalLight.position.set(-1, 1, 1).normalize();
      scene.add(directionalLight);

      //

      renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      effect = new THREE.OutlineEffect(renderer);

      // STATS

      stats = new Stats();
      container.appendChild(stats.dom);

      // model

      var onProgress = function(xhr) {
        if (xhr.lengthComputable) {
          var percentComplete = xhr.loaded / xhr.total * 100;
          console.log(Math.round(percentComplete, 2) + '% downloaded');
        }
      };

      var onError = function(xhr) {};

      var modelFile = 'miku_v2.pmd';
      var vmdFiles = ['wavefile_v2.vmd'];

      helper = new THREE.MMDHelper();

      var loader = new THREE.MMDLoader();

      loader.load(modelFile, vmdFiles, function(object) {
        mesh = object;
        mesh.position.y = -10;
        scene.add(mesh);

        helper.add(mesh);
        helper.setAnimation(mesh);

        /*
         * Note: create CCDIKHelper after calling helper.setAnimation()
         */
        ikHelper = new THREE.CCDIKHelper(mesh);
        ikHelper.visible = false;
        scene.add(ikHelper);

        /*
         * Note: You're recommended to call helper.setPhysics()
         *       after calling helper.setAnimation().
         */
        helper.setPhysics(mesh);
        physicsHelper = new THREE.MMDPhysicsHelper(mesh);
        physicsHelper.visible = false;
        scene.add(physicsHelper);

        helper.unifyAnimationDuration({
          afterglow: 2.0
        });

        initGui();

      }, onProgress, onError);

      var controls = new THREE.OrbitControls(camera, renderer.domElement);

      window.addEventListener('resize', onWindowResize, false);

      var phongMaterials;
      var originalMaterials;

      function makePhongMaterials(materials) {

        var array = [];

        for (var i = 0, il = materials.length; i < il; i++) {

          var m = new THREE.MeshPhongMaterial();
          m.copy(materials[i]);
          m.needsUpdate = true;

          array.push(m);

        }

        phongMaterials = array;

      }

      function initGui() {

        var api = {
          '加速度': 9.8
        };

        var gui = new dat.GUI();

        gui.add(api, '加速度', 5.0, 15.0).onChange(function() {
          a = $('.c input').val();
          aFlag = true;
          clock.stop();
          clock.start();
        });
      }

    }

    function onWindowResize() {

      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      effect.setSize(window.innerWidth, window.innerHeight);

    }

    //

    function animate() {
      requestAnimationFrame(animate);
      stats.begin();
      render(mesh);
      stats.end();

    }

    function render() {
      let g = 9.8;
      let fa = a - g;
      helper.animate(clock.getDelta());
      let dt2;
      if (gg > 3) {
        dt2 = Math.pow(clock.elapsedTime, 2);
        if (fa < 0 && ny > -10) {
          console.log('down');
          ny += (fa * dt2) / 2;
        } else if (fa >= 0) {
          ny += (fa * dt2) / 2;
        } else {
          ny = -10;
        }
      }
      if (physicsHelper !== undefined && physicsHelper.visible) physicsHelper.update();
      if (ikHelper !== undefined && ikHelper.visible) ikHelper.update();
      (gf >= 0) ? console.log(a, ny): gf = false;
      gf--;
      gg++;
      if (helper.meshes[0] !== undefined) {
        helper.meshes[0].position.setY(ny);
      }
      effect.render(scene, camera);
    }



    init();
    animate();

  </script>

</body>

</html>
